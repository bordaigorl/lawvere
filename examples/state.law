// define a free category extension:

sketch State =
  { ob S,
    ar get : {} -> S,
    ar put : S -> {}
  }


// We define some arrows in `Base[State, S=Int]`
// This is the free extension of Base by the sketch State, in which furthermore,
// S and Int are the same object.
// In other words, when functoring from Base[State, S = Int], one will have to send S and Int to
// the same object of the target category.

ar Base[State, S = Int]  next : {} -> S =
  get
  { current = ,
    next = inc put }
  .current

// Using `next` we can define a labelling function:

ar Base[State, S = Int]  label : String -> (Int, String) =
  ({} next, )

// Which we can use to label strings in a list:

ar Base[State, S = Int] index : list(String) -> list((Int, String)) =
  ( const(label), ) map


// We can define a functor from `Base[State, S = Int]` to `Base`:


ar Cat pureIntState : Base[State, S = Int] --> Base =
  { state : const(Int), val : }


// use said functor:

indexPure : list(String) -> list((Int, String))
indexPure =
  {state: 0, val: }    // initialise the state to 0
  pureIntState(index)  // invoke a stateful computation
  .val                 // discard the state

